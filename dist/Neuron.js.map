{"version":3,"sources":["../src/Neuron.js"],"names":["randomType","Types","Enum","initEnum","NORMAL","INPUT","OUTPUT","Neuron","threshold","stability","filter","type","connections","buffer","charge","phase","chargeObj","triggers","cleanBuffer","push","summedCharge","sumBuffer","forEach","Math","random","connection","probability","offset","i","length","slice","reduce","sum","a","b","c","undefined","hasDominantType","dominantType","max","conA","conB","crossConnections","toFixed"],"mappings":"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","file":"Neuron.js","sourcesContent":["import {rndBool, rndTrinary, rndTrinaryEq} from \"./evoHelpers\";\r\nimport {Enum} from 'enumify';\r\n\r\n//TODO: Create Brain to contain and manage neurons.\r\n\r\n/** The possible types for a neuron.\r\n * Here, Input and Output are dominant over Normal,\r\n * and breed accordingly.\r\n * @typedef {{INPUT, OUTPUT, NORMAL}} Types\r\n */\r\n\r\nexport class Types extends Enum {\r\n}\r\n\r\nTypes.initEnum(['INPUT', 'NORMAL', 'OUTPUT']);\r\n\r\nexport function randomType(){\r\n    return rndTrinary(Types.NORMAL, Types.NORMAL, rndBool() ? Types.INPUT : Types.OUTPUT);\r\n}\r\n\r\nclass Neuron {\r\n    /**\r\n     * A trigger object. This describes a charge \"triggering\"\r\n     * to be performed by the network.\r\n     * @typedef {{\r\n     *      offset:number,\r\n     *      charge:number\r\n     *  }} Trigger\r\n     */\r\n\r\n    /**\r\n     * A buffer object. Describes a previous incoming charge.\r\n     * @typedef {{charge:number, phase: number}} Charge\r\n     */\r\n\r\n    /**\r\n     * Describes a connection to another neuron.\r\n     * Offset describes the index offset between this neuron and its connection.\r\n     * Offset, rather than hard \"id's\" are used to allow more organic growth.\r\n     * If surrounding connections are augmented, through mutation, this allows the connections to flexibly match\r\n     * the mutation. The resulting randomness betters selection based mutation.\r\n     * @typedef {\r\n     *      {\r\n     *          offset: number\r\n     *          filter: number\r\n     *          probability: number\r\n     *      }\r\n     * } Connection\r\n     */\r\n\r\n    /**\r\n     *\r\n     * @param {number} threshold\r\n     * @param {number} stability\r\n     * @param {number} filter\r\n     * @param {string} type\r\n     * @param {Connection[]} connections\r\n     */\r\n    constructor({threshold, stability, filter, type = Types.NORMAL, connections = []}) {\r\n\r\n        /**\r\n         * A record of all incoming charges, and the phase they came in.\r\n         * @type {Charge[]}\r\n         */\r\n        this.buffer = [];\r\n\r\n        /**\r\n         * The minimum buffer sum required to activate.\r\n         * @type {number}\r\n         */\r\n        this.threshold = threshold;\r\n\r\n        /** The value of incoming charge to pass on to connections.\r\n         * @type {number}\r\n         */\r\n        this.filter = filter;\r\n        /**\r\n         * The number of phases for which a charge will be retained in buffer.\r\n         * @type {number}\r\n         */\r\n        this.stability = stability;\r\n\r\n        /**\r\n         * The type of neuron, input, output, or normal.\r\n         * This influences breeding.\r\n         * @type {string}\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Connections for this neuron.\r\n         * @type {Connection[]}\r\n         */\r\n        this.connections = connections;\r\n    }\r\n\r\n    /**\r\n     * Given an incoming charge, compute all necessary outgoing charges.\r\n     * @param {number} charge\r\n     * @param {number} phase\r\n     * @return {Trigger[]}\r\n     */\r\n    trigger(charge, phase) {\r\n        /**@type{Charge}*/\r\n        const chargeObj = {\r\n            charge: charge,\r\n            phase: phase\r\n        }\r\n        const triggers = [];\r\n        /**\r\n         * Remove any items from history where\r\n         * phase is older than stability.\r\n         */\r\n        this.cleanBuffer(phase);\r\n\r\n        /**\r\n         * Add this new charge to the buffer.\r\n         */\r\n        this.buffer.push(chargeObj);\r\n\r\n        /**\r\n         * If total charge > threshold,\r\n         * iterate through connections.\r\n         * For each one compute filtered charge, and return all pending triggers.\r\n         */\r\n        const summedCharge = this.sumBuffer();\r\n        if (summedCharge > this.threshold) {\r\n            this.connections.forEach(connection => {\r\n                if (Math.random() < connection.probability) {\r\n                    triggers.push({\r\n                        offset: connection.offset,\r\n                        charge: summedCharge * this.filter * connection.filter\r\n                    })\r\n                }\r\n            })\r\n        }\r\n\r\n        return triggers;\r\n    }\r\n\r\n\r\n    /**\r\n     * Remove any buffer items where phase is older than stability allows.\r\n     * @param {number} phase\r\n     */\r\n    cleanBuffer(phase) {\r\n        /**\r\n         * Iterate through backwards. As new items add to end, this means\r\n         * we will reach the \"final too old\" faster.\r\n         */\r\n        for (let i = this.buffer.length - 1; i >= 0; i--) {\r\n            /**Find last occurance that is too old.*/\r\n            if (this.buffer[i].phase < phase - this.stability) {\r\n                /**Set buffer = to only what is after this item.*/\r\n                this.buffer = this.buffer.slice(i + 1, this.buffer.length - 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Find the total accumulated charge in the buffer.\r\n     * @return {number}\r\n     */\r\n    sumBuffer() {\r\n        return this.buffer.reduce((sum, charge) => sum + charge.charge, 0);\r\n    }\r\n\r\n    /**\r\n     * Breed two neurons to return a third one, with mutations possible.\r\n     * @param {Neuron} a\r\n     * @param {Neuron} b\r\n     * @return {Neuron}\r\n     */\r\n    static cross(a, b) {\r\n        /**\r\n         * Initialize properties for a hybrid neuron.\r\n         * For each property, there is a 50% chance of a or b.\r\n         * Init connections to an empty array though, that is seperate.\r\n         */\r\n        let c = {\r\n            threshold: rndTrinary(a.threshold, b.threshold, Math.random()),\r\n            stability: rndTrinary(a.stability, b.stability, Math.random()),\r\n            filter: rndTrinary(a.filter, b.filter, Math.random()),\r\n            type: undefined,\r\n            connections: []\r\n        }\r\n\r\n        if (a.hasDominantType() == b.hasDominantType()) {\r\n            c.type = rndTrinary(a.type, b.type, randomType())\r\n        } else {\r\n            let dominantType = a.hasDominantType() ? a.type : b.type\r\n            c.type = rndTrinary(dominantType, dominantType, randomType())\r\n        }\r\n\r\n        /**\r\n         * Iterate through whichever list of connections is bigger, a or b.\r\n         * This way, we'll be able to sequence every connection.\r\n         */\r\n        for (let i = 0; i < Math.max(a.connections.length, b.connections.length); i++) {\r\n            /**\r\n             * Get the connections at this index in both neurons. This may be undefined in up to one neuron.\r\n             * @type {Connection} conA\r\n             * @type {Connection} conB\r\n             */\r\n            const conA = a.connections[i];\r\n            const conB = b.connections[i];\r\n\r\n            /**\r\n             * If there is a connection element at this index for both a and b,\r\n             *      there is a 49% chance (each) of pushing conA or conB.\r\n             *      And a 2% chance of crossing.\r\n             */\r\n            if (conA && conB) {\r\n\r\n                /**\r\n                 * 99.5% chance of pushing either connection A, B, or a mutant thereof.\r\n                 */\r\n                if (Math.random() < 0.995) {\r\n                    c.connections.push(rndTrinary(conA, conB, Neuron.crossConnections(conA, conB)));\r\n                } else {\r\n                    /**\r\n                     * .5% chance of pushing both connections A and B.\r\n                     */\r\n                    c.connections.push(conA, conB)\r\n                }\r\n            } else if (rndBool()) {\r\n                /**\r\n                 * If connections A and B don't both exist, 50% chance of pushing the existing one.\r\n                 */\r\n                c.connections.push(conA || conB);\r\n            }\r\n        }\r\n        return new Neuron(c);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the 'type' of this neuron is dominant.\r\n     * Inputs and Output are dominant, normal is recessive.\r\n     * @return {boolean}\r\n     */\r\n    hasDominantType() {\r\n        return this.type == Types.INPUT || this.type == Types.OUTPUT;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Connection} conA\r\n     * @param {Connection} conB\r\n     * @return {Connection}\r\n     */\r\n    static crossConnections(conA, conB) {\r\n        return ({\r\n            offset: rndTrinary(conA.offset, conB.offset, (Math.random() * 10 - Math.random() * 10).toFixed(0)),\r\n            filter: rndTrinary(conA.filter, conB.filter, Math.random()),\r\n            probability: rndTrinary(conA.probability, conB.probability, Math.random())\r\n        });\r\n    }\r\n}\r\n\r\nexport default Neuron;"]}