{"version":3,"sources":["../src/Neuron.js"],"names":["Neuron","threshold","stability","filter","connections","buffer","charge","phase","chargeObj","triggers","cleanBuffer","push","summedCharge","sumBuffer","forEach","Math","random","connection","probability","offset","i","length","slice","reduce","sum","a","b","c","max","conA","conB","crossConnections"],"mappings":"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","file":"Neuron.js","sourcesContent":["import {rndBool, rndTrinary} from \"./evoHelpers\";\r\n\r\nclass Neuron {\r\n    /**\r\n     * A trigger object. This describes a charge \"triggering\"\r\n     * to be performed by the network.\r\n     * @typedef {{\r\n     *      offset:number,\r\n     *      charge:number\r\n     *  }} Triggerr\r\n     */\r\n\r\n    /**\r\n     * A buffer object. Describes a previous incoming charge.\r\n     * @typedef {{charge:number, phase: number}} Charge\r\n     */\r\n\r\n    /**\r\n     * Describes a connection to another neuron.\r\n     * Offset describes the index offset between this neuron and its connection.\r\n     * Offset, rather than hard \"id's\" are used to allow more organic growth.\r\n     * If surrounding connections are augmented, through mutation, this allows the connections to flexibly match\r\n     * the mutation. The resulting randomness betters selection based mutation.\r\n     * @typedef {\r\n     *      {\r\n     *          offset: number\r\n     *          filter: number\r\n     *          probability: number\r\n     *      }\r\n     * } Connection\r\n     */\r\n\r\n    /**\r\n     *\r\n     * @param {number} threshold\r\n     * @param {number} stability\r\n     * @param {number} filter\r\n     * @param {Connection[]} connections\r\n     */\r\n    constructor({threshold, stability, filter, connections = []}) {\r\n\r\n        /**\r\n         * A record of all incoming charges, and the phase they came in.\r\n         * @type {Charge[]}\r\n         */\r\n        this.buffer = [];\r\n\r\n        /**\r\n         * The minimum buffer sum required to activate.\r\n         * @type {number}\r\n         */\r\n        this.threshold = threshold;\r\n\r\n        /** The value of incoming charge to pass on to connections.\r\n         * @type {number}\r\n         */\r\n        this.filter = filter;\r\n        /**\r\n         * The number of phases for which a charge will be retained in buffer.\r\n         * @type {number}\r\n         */\r\n        this.stability = stability;\r\n\r\n        /**\r\n         * Connections for this neuron.\r\n         * @type {Connection[]}\r\n         */\r\n        this.connections = connections;\r\n    }\r\n\r\n    /**\r\n     * Given an incoming charge, compute all necessary outgoing charges.\r\n     * @param {number} charge\r\n     * @param {number} phase\r\n     * @return {Trigger[]}\r\n     */\r\n    trigger(charge, phase) {\r\n        /**@type{Charge}*/\r\n        const chargeObj = {\r\n            charge: charge,\r\n            phase: phase\r\n        }\r\n        const triggers = [];\r\n        /**\r\n         * Remove any items from history where\r\n         * phase is older than stability.\r\n         */\r\n        this.cleanBuffer(phase);\r\n\r\n        /**\r\n         * Add this new charge to the buffer.\r\n         */\r\n        this.buffer.push(chargeObj);\r\n\r\n        /**\r\n         * If total charge > threshold,\r\n         * iterate through connections.\r\n         * For each one compute filtered charge, and return all pending triggers.\r\n         */\r\n        const summedCharge = this.sumBuffer();\r\n        if (summedCharge > this.threshold) {\r\n            this.connections.forEach(connection => {\r\n                if (Math.random() < connection.probability) {\r\n                    triggers.push({\r\n                        offset: connection.offset,\r\n                        charge: summedCharge * this.filter * connection.filter\r\n                    })\r\n                }\r\n            })\r\n        }\r\n\r\n        return triggers;\r\n    }\r\n\r\n\r\n    /**\r\n     * Remove any buffer items where phase is older than stability allows.\r\n     * @param {number} phase\r\n     */\r\n    cleanBuffer(phase) {\r\n        /**\r\n         * Iterate through backwards. As new items add to end, this means\r\n         * we will reach the \"final too old\" faster.\r\n         */\r\n        for (let i = this.buffer.length - 1; i >= 0; i--) {\r\n            /**Find last occurance that is too old.*/\r\n            if (this.buffer[i].phase < phase - this.stability) {\r\n                /**Set buffer = to only what is after this item.*/\r\n                this.buffer = this.buffer.slice(i + 1, this.buffer.length - 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Find the total accumulated charge in the buffer.\r\n     * @return {number}\r\n     */\r\n    sumBuffer() {\r\n        return this.buffer.reduce((sum, charge) => sum + charge.charge, 0);\r\n    }\r\n\r\n    /**\r\n     * Breed two neurons to return a third one, with mutations possible.\r\n     * @param {Neuron} a\r\n     * @param {Neuron} b\r\n     * @return {Neuron}\r\n     */\r\n    static cross(a, b) {\r\n        /**\r\n         * Initialize properties for a hybrid neuron.\r\n         * For each property, there is a 50% chance of a or b.\r\n         * Init connections to an empty array though, that is seperate.\r\n         */\r\n        let c = {\r\n            threshold: rndTrinary(a.threshold, b.threshold, Math.random()),\r\n            stability: rndTrinary(a.stability, b.stability, Math.random()),\r\n            filter: rndTrinary(a.filter, b.filter, Math.random()),\r\n            connections: []\r\n        }\r\n\r\n        /**\r\n         * Iterate through whichever list of connections is bigger, a or b.\r\n         * This way, we'll be able to sequence every connection.\r\n         */\r\n        for (let i = 0; i < Math.max(a.connections.length, b.connections.length); i++) {\r\n            /**\r\n             * Get the connections at this index in both neurons. This may be undefined in up to one neuron.\r\n             * @type {Connection} conA\r\n             * @type {Connection} conB\r\n             */\r\n            let conA = a.connections[i];\r\n            let conB = b.connections[i];\r\n\r\n            /**\r\n             * If there is a connection element at this index for both a and b,\r\n             *      there is a 49% chance (each) of pushing conA or conB.\r\n             *      And a 2% chance of crossing.\r\n             */\r\n            if (conA && conB) {\r\n\r\n                /**\r\n                 * 99.5% chance of pushing either connection A, B, or a mutant thereof.\r\n                 */\r\n                if (Math.random() < 0.995) {\r\n                    c.connections.push(rndTrinary(conA, conB, Neuron.crossConnections(conA, conB)));\r\n                } else {\r\n                    /**\r\n                     * .5% chance of pushing both connections A and B.\r\n                     */\r\n                    c.connections.push(conA, conB)\r\n                }\r\n            } else if (rndBool()) {\r\n                /**\r\n                 * If connections A and B don't both exist, 50% chance of pushing the existing one.\r\n                 */\r\n                c.connections.push(conA || conB);\r\n            }\r\n        }\r\n        return new Neuron(c);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Connection} conA\r\n     * @param {Connection} conB\r\n     * @return {Connection}\r\n     */\r\n    static crossConnections(conA, conB) {\r\n        return ({\r\n            offset: rndTrinary(conA.offset, conB.offset, Math.random() * 10 - Math.random() * 10),\r\n            filter: rndTrinary(conA.filter, conB.filter, Math.random()),\r\n            probability: rndTrinary(conA.probability, conB.probability, Math.random())\r\n        });\r\n    }\r\n}\r\n\r\nexport default Neuron;"]}