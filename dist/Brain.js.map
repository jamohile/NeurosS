{"version":3,"sources":["../src/Brain.js"],"names":["Brain","neurons","inputs","outputs","parseIO","forEach","n","type","Types","INPUT","push","OUTPUT","a","b","c","i","Math","max","length","nA","nB","random","Neuron","cross"],"mappings":";;;;;;;;;AAAA;;;;AACA;;;;;;IAEaA,K,WAAAA,K;AAET,yBAA2B;AAAA,gCAAdC,OAAc;AAAA,YAAdA,OAAc,gCAAJ,EAAI;;AAAA;;AACvB;;;;;AAKA,aAAKA,OAAL,GAAeA,OAAf;AACA,aAAKC,MAAL,GAAc,EAAd;AACA,aAAKC,OAAL,GAAe,EAAf;AACA,aAAKC,OAAL;AACH;;AAED;;;;;;;;kCAIS;AAAA;;AACL,iBAAKH,OAAL,CAAaI,OAAb,CAAqB,aAAK;AACtB,wBAAOC,EAAEC,IAAT;AACI,yBAAKC,cAAMC,KAAX;AACI,8BAAKP,MAAL,CAAYQ,IAAZ,CAAiBJ,CAAjB;AACA;AACJ,yBAAKE,cAAMG,MAAX;AACI,8BAAKR,OAAL,CAAaO,IAAb,CAAkBJ,CAAlB;AACA;AANR;AAQH,aATD;AAUH;;AAED;;;;;;;;;8BAMaM,C,EAAGC,C,EAAE;AACd,gBAAMC,IAAI;AACNb,yBAAS;AADH,aAAV;AAGA,iBAAI,IAAIc,IAAI,CAAZ,EAAeA,IAAIC,KAAKC,GAAL,CAASL,EAAEX,OAAF,CAAUiB,MAAnB,EAA2BL,EAAEZ,OAAF,CAAUiB,MAArC,CAAnB,EAAiEH,GAAjE,EAAqE;AACjE;;;;;;AAMA,oBAAMI,KAAKP,EAAEX,OAAF,CAAUc,CAAV,CAAX;AACA,oBAAMK,KAAKP,EAAEZ,OAAF,CAAUc,CAAV,CAAX;;AAEA,oBAAGI,MAAMC,EAAT,EAAY;AACR,wBAAGJ,KAAKK,MAAL,KAAgB,KAAnB,EAAyB;AACrBP,0BAAEb,OAAF,CAAUS,IAAV,CAAe,4BAAWS,EAAX,EAAeC,EAAf,EAAmBE,iBAAOC,KAAP,CAAaJ,EAAb,EAAiBC,EAAjB,CAAnB,CAAf;AACH,qBAFD,MAEK;AACDN,0BAAEb,OAAF,CAAUS,IAAV,CAAeS,EAAf,EAAmBC,EAAnB;AACH;AACJ,iBAND,MAMM,IAAG,0BAAH,EAAa;AACfN,sBAAEb,OAAF,CAAUS,IAAV,CAAeS,MAAMC,EAArB;AACH;AACJ;AACD,mBAAO,IAAIpB,KAAJ,CAAUc,CAAV,CAAP;AACH","file":"Brain.js","sourcesContent":["import Neuron, {Types} from './Neuron';\r\nimport {rndBool, rndTrinary} from \"./evoHelpers\";\r\n\r\nexport class Brain{\r\n\r\n    constructor({neurons = []}){\r\n        /**\r\n         * @type {Neuron[]} neurons\r\n         * @type {Neuron[]} inputs\r\n         * @type {Neuron[]} outputs\r\n         */\r\n        this.neurons = neurons;\r\n        this.inputs = [];\r\n        this.outputs = [];\r\n        this.parseIO();\r\n    }\r\n\r\n    /**\r\n     * Iterate through neurons,\r\n     * push inputs and output into their buffers.\r\n     */\r\n    parseIO(){\r\n        this.neurons.forEach(n => {\r\n            switch(n.type){\r\n                case Types.INPUT:\r\n                    this.inputs.push(n)\r\n                    break;\r\n                case Types.OUTPUT:\r\n                    this.outputs.push(n)\r\n                    break;\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Breed two brains to return a third brain.\r\n     * @param {Brain} a\r\n     * @param {Brain} b\r\n     * @return {Brain}\r\n     */\r\n    static cross(a, b){\r\n        const c = {\r\n            neurons: []\r\n        };\r\n        for(let i = 0; i < Math.max(a.neurons.length, b.neurons.length); i++){\r\n            /**\r\n             * Get the neuron at this index for both neurons.\r\n             * This may be undefined for one neuron.\r\n             * @type {Neuron} nA\r\n             * @type {Neuron} nB\r\n             */\r\n            const nA = a.neurons[i];\r\n            const nB = b.neurons[i];\r\n\r\n            if(nA && nB){\r\n                if(Math.random() < 0.995){\r\n                    c.neurons.push(rndTrinary(nA, nB, Neuron.cross(nA, nB)));\r\n                }else{\r\n                    c.neurons.push(nA, nB);\r\n                }\r\n            }else if(rndBool()){\r\n                c.neurons.push(nA || nB);\r\n            }\r\n        }\r\n        return new Brain(c);\r\n    }\r\n}"]}